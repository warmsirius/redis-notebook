# 3. RDB和AOF的比较

## 3.1 RDB vs. AOF
### RDB
RDB持久化方式能够在指定时间间隔能对你的数据进行快照存储。

### AOF
AOF持久化方式记录每次对服务器写的操作，当服务器重启时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾。

Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。


## 3.2 Redis 只做缓存
如果你只希望你的数据在服务器运行的时候存在，也可以不适用任何持久化方式。


## 3.3 同时开启 2种持久化

在这种情况下，**当Redis重启时候会优先载入AOF文件来恢复原始的数据**。

因为在通常情况下，AOF文件保存的数据要比RDB文件保存的数据集完整。 RDB数据不实时，同时使用两者时，服务器重启也只会找AOF文件。

### 问题: 要不要只使用AOF？
建议: 不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，AOF可能有潜在的bug，留着作为一个万一的手段。


## 3.4 性能建议
因为RDB文件只作后备用途，建议只在Slave上持久化RDB文件，而且只要15min备份一次就够了，只保留 `save 900 1`这条规则。

### Enable AOF
如果 Enable AOF，好处是在最恶劣的情况下也只会丢失不超过2s的数据，启动脚本较简单只 load自己的AOF文件就可以了。

### Enable AOF 代价: 
* 1.带来了持续的IO
* 2.AOF Rewrite的最后会将 Rewrite过程产生的新数据写到新文件造成的阻塞几乎是不可避免的

只要硬盘许可，应该尽量减少 AOF Rewrite的频率，AOF重写的基础大小默认值 64M太小了，可以设置到 5G以上。默认超过原大小 100%大小时重写可以改到适当数值。

### Disable AOF
如果 Disable AOF，仅靠Master-Slave Replication 实现高可用也可以。能省掉1大笔IO，也减少了rewrite时带来的系统波动。

### Disable AOF代价
如果是Master/Slave同时挂掉，会丢失十几分钟的数据，启动脚本也要比两个 Master/Slave中的RDB文件，载入较新的那个。(新浪选用这个方案)
