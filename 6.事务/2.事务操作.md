# 2. Redis 事务操作

## 2.1 Redis 事务命令
下表列出了 Redis事务的命令:

| 命令 | 描述 |
|----|----|
| DISCARD | 取消事务，放弃执行事务块内的所有命令 |
| EXEC | 执行所有事务块内命令 |
| MULTI | 标记1个事务块的开始 |
| UNWATCH | 取消WATCH命令对所有key的监视 |
| WATCH key [key ...] | 监视1个或多个key，如果在事务执行之前这个(或这些)key被其他命令所修改，那么事务将被打断 |


## 2.2 Redis事务提交原则
* 检查时(进入Queue)错误: 不会提交所有的命令
* 运行时错误: 冤有头债有主，谁错了谁不提交，其他的不影响


## 2.3 watch监控
### 悲观锁 
每次拿数据都认为别人会修改，所以每次在拿数据时都会上锁，这样别人想拿这个数据就会block直到他拿到锁。

传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先上锁。

### 乐观锁
每次拿数据时都认为别人不会修改，所以不会上锁，但是在更新时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁适用于多读的应用类型，这样可以提高吞吐量。

> 乐观锁策略: 提交版本必须大于记录当前版本才能执行更新。

`注意`: 一旦执行了 exec，之前加的监控锁都会被取消掉。

### CAS
Check And Set

### watch监控
* watch指令，类似乐观锁，事务提交时，如果key的值已被别的客户端改变，比如某个list已被别的客户端 push/pop过，整个事务队列都不会被执行

* 通过watch命令在事务执行之前监控了多个keys，倘若在 watch之后有任何key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回 Nullmulti-bulk应答以通知调用者事务执行失败。


## 2.4 事务3阶段
* 开启: 以MULTI开始1个事务
* 入队: 将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
* 执行: 由EXEC命令触发事务


## 2.5 事务3特性
* 单独的隔离性

事务中所有命令都会序列化、按顺序地执行。事务在执行过程中，不会被其他客户发送来的命令所打算。

* 没有隔离级别的概念

队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在"事务内的查询要看到事务里的更新，在事务外查询不能看到" 这个让人万分头痛的问题。

* 不保证原子性

redis同一个事务中如果有1条命令执行失败，其后的命令仍然会被执行，并没有回滚。
